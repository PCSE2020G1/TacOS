#include <stdio.hmm>
#include <stdlib.hmm>
#include <string.hmm>

#include <ctype.hmm>
#ifndef C
#include <syslib.hmm>                    // TaC版は一部のシステムコールを使う
#include <crt0.hmm>                      // TaC版は _addrAdd を使用する
#else
void[] _addrAdd(void[] p, int i);        // C版ではマニュアルに無いが使用できる
#endif

#define ROWS 80
#define COLUMNS 24
#define LINES 150
#define BUFLEN 80

struct cursor{
  int x;
  int y;
};

int top;    // 一番上にある行
int current;// 今の行
int lines;  // 合計行数

cursor c;
char[][] textBuffer = array(LINES, BUFLEN); // 入力文字格納用
char[] kbdBuf=array(BUFLEN + 1);            // 入力用

char[] d = array(BUFLEN + 2); // 行内容の更新用
int mode;     // 普通のモード
int rawMode;  // １文字入力

// 初期化
void init(){
  top = 0;
  c.x = 0;
  c.y = 0;
  current = 0;
  lines = 0;
  mode = ttyCtl(TTYCTL_GETMODE, 0);
  rawMode = mode & ~TTYCTL_MODE_ECHO & ~TTYCTL_MODE_COOKED;
}

// カーソルを右へ
void move_right(){
  c.x = c.x + 1;
  // 最大数を超えない
  if(c.x >= ROWS){
    c.x = ROWS - 1;
  }
}

//　カーソルを左へ
void move_left(){
  c.x = c.x - 1
  // 0より小さくならない
  if(c.x > 0){
    c.x = 0;
  }
}

// カーソルを下へ
void move_down(){
  if(current == lines){
    return;
  }
  c.x = 0;  // xを左端に移動
  c.y = c.y + 1;
  current = current + 1;

  if(c.y >= COLUMNS){
    c.y = COLUMNS - 1;
    // 下に表示可能な部分があれば一番上の行を更新
    if(top + (COLUMNS-1) < lines){
      top = top + 1;
    }
  }
}

// カーソルを上へ
void move_up(){
  if(current == 0){
    return;
  }
  c.x = 0;
  current = current - 1;
  c.y = c.y - 1;

  if(c.y < 0){
    c.y = 0;
    // 上に表示可能な部分があれば一番上の行を更新
    if(top > 0){
      top = top - 1;
    }
  }
}

// 新しい行追加
void add_newline(){
  int i;
  lines = lines + 1;
  move_down();

  // 行の挿入の場合は現在行から後ろをずらす
  if (current != lines){
    for(i = lines; i > current; i = i - 1){
      strCpy(textBuffer[i], textBuffer[i-1]);
    }
  }
  c.x = 0;
}

// 文字挿入
void insert_char(char ch){
  int i;
  int length = strLen(textBuffer[current]) + 1; // 挿入後の文字数

  if (length == ROWS){
    add_newline();
    length = 1; // 挿入後の文字数
  }

  for(i = 0; i < BUFLEN + 2; i = i + 1){
    d[i] = '\0';
  }

  // 更新する情報を作成
  for(i = 0; i < length; i = i + 1){
    // 挿入部分まではそのまま
    if(i < c.x){
      d[i] = textBuffer[current][i];
    } else {
      // 挿入部分後は１つずらす
      if(i > c.x){
        d[i] = textBuffer[current][i-1];
      } else if(i == c.x){
      // 挿入部分に代入
        d[i] = ch;
      }
    }
  }

  move_right();
  // 内容更新
  strNcpy(textBuffer[current], d, length);
}

// 文字削除
void remove_char(){
  // その行の内容が０なら後ろの行から詰める
  if(strLen(textBuffer[current]) == 0){
    if(current == 0){
      return;
    }
    for (int i = current ; i < lines; i = i + 1){
      strCpy(textBuffer[i-1], textBuffer[i]);
    }
    lines = lines - 1;
    move_up();
    c.x = strLen(textBuffer[current]) - 1;
  } else {
    // 後ろの文字を詰める
    for(int i = c.x; i < strLen(textBuffer[current]); i = i + 1){
      textBuffer[current][i] = textBuffer[current][i+1];
    }
    // 最後の文字はnullにする
    textBuffer[current][strLen(textBuffer[current])] = '\0';
  }
}

// 画面表示
void display(){
  // 画面クリア
  printf("\x1b[2J\x1b[H");
  int end = lines + 1;
  if(end >  COLUMNS){
    end = COLUMNS;
  }
  // 表示
  for(int i = top; i < top + end; i = i + 1){
    printf("\r");
    printf("%s", textBuffer[i]);
    if (strRchr(textBuffer[i], '\n') == -1) {
      printf("\n");
    }
  }
  // カーソル移動
  printf("\x1b[%d;%dH", (c.y+1), (c.x+1));
}

// ファイルから１行読み出す
boolean getLine(char[] buf, int buflen, FILE fp) {
  if (fgets(buf, buflen, fp) == null) {
    return false;
  }
  if (strLen(buf) >= buflen) {
    return false;
  }
  return true;
}

// 入力文字の処理
void keyboard(char key){
    // todo エスケープシーケンスで動くようにする
    if (key == 'u'){  // up
      move_up();
      printf("\x1b[1A");
      display();
      return;
    }else if (key == 'd'){  // down
      move_down();
      display();
      return;
    } else if (key == 'r'){ // right
      move_right();
      printf("\x1b[1C");
      return;
    } else if (key == 'l'){  // left
      move_left();
      printf("\x1b[1D");
      return;
    } else if (key == chr(9)){    // tab
      for(int i = 0; i < 8; i = i + 1){
        insert_char(' ');
      }
      return;
    } else if (key == '\x08'){    // del
      remove_char();
      move_left();
      display();
      return;
    } else if (key == '\r' || key == '\n'){
      printf("\r");
      insert_char('\n');
      add_newline();
      display();
      return;
    }
    insert_char(key);
    printf("%c", key);
    return;
}

// ファイルの内容を処理
void loadfile(char[] filename) {
  FILE fp;
  char ch;
  fp = fopen(filename, "r"); // ファイルを開く
  if (fp == null) {
    perror(filename);
    printf("\x1b[2J\x1b[H");
  } else {
    while(!feof(fp)) {
      ch = fgetc(fp);
      keyboard(ch);
    }
    fclose(fp);
  }
}

// ファイルに書き込む
void savefile(char[] filename) {
  #ifndef C
    remove(filename);
  #endif

  FILE fp;
  fp = fopen(filename, "w");
  if (fp == null) {
    perror(filename);
    return;
  }
  for(int i = 0; i < lines; i = i + 1){
    fprintf(fp, "%s", textBuffer[i]);
  }
  fclose(fp);
}

public int main(int argc, char[][] argv){
  if(argc!=2){
    fprintf(stderr, "Usage, %s <filename>\n", argv[0]);
    return 1;
  }
  init();
  char[] filename = argv[1];
  stdout.buf = null;  // printf \n なしで使えるようにする
  printf("\x1b[2J\x1b[H");

  char ch;
  loadfile(filename);

  ttyCtl(TTYCTL_SETMODE, rawMode);

  while(true){
    // 文字入力
    ttyRead(kbdBuf, 1);

    // qを押したら終わり
    // todo 終わり方をかんがえる
    ch = kbdBuf[0];
    if(ch == 'q'){
      break;
    }
    keyboard(ch);
  }
  // save
  ttyCtl(TTYCTL_SETMODE, mode);
  savefile(filename);

  printf("\r\n");
  return 0;
}
