#include <stdio.hmm>
#include <stdlib.hmm>
#include <string.hmm>

#include <ctype.hmm>
#ifndef C
#include <syslib.hmm>                    // TaC版は一部のシステムコールを使う
#include <crt0.hmm>                      // TaC版は _addrAdd を使用する
#else
void[] _addrAdd(void[] p, int i);        // C版ではマニュアルに無いが使用できる
#endif

#define ROWS 80
#define COLUMNS 24
#define LINES 150
#define BUFLEN 80

struct cursor{
  int x;
  int y;
};

int top;    // 表示領域の一番上にある行
int current;// 今の行
int lines;  // 合計行数

cursor c = {0, 0};
char[][] textBuffer = array(LINES, BUFLEN); // 入力文字格納用
char[] kbdBuf=array(BUFLEN + 1);            // 入力用

char[] d = array(BUFLEN + 2); // 行内容の更新用

// 初期化
void init(){
  top = 0;
  current = 0;
  lines = 0;
}

// カーソルを右へ
void moveRight(){
  c.x = c.x + 1;
  // 最大数を超えない
  if(c.x >= ROWS){
    c.x = ROWS - 1;
  }
}

//　カーソルを左へ
void moveLeft(){
  c.x = c.x - 1;
  // 0より小さくならない
  if(c.x > 0){
    c.x = 0;
  }
}

// カーソルを下へ
void moveDown(){
  if(current == lines){
    return;
  }
  c.x = 0;  // xを左端に移動
  c.y = c.y + 1;
  current = current + 1;

  if(c.y >= COLUMNS){
    c.y = COLUMNS - 1;
    // 下に表示可能な部分があれば一番上の行を更新
    if(top + (COLUMNS-1) < lines){
      top = top + 1;
    }
  }
}

// カーソルを上へ
void moveUp(){
  if(current == 0){
    return;
  }
  c.x = 0;
  current = current - 1;
  c.y = c.y - 1;

  if(c.y < 0){
    c.y = 0;
    // 上に表示可能な部分があれば一番上の行を更新
    if(top > 0){
      top = top - 1;
    }
  }
}

// 新しい行追加
void addNewLine(){
  int i;
  lines = lines + 1;
  moveDown();

  // 行の挿入の場合は現在行から後ろをずらす
  if (current != lines){
    for(i = lines; i > current; i = i - 1){
      strCpy(textBuffer[i], textBuffer[i-1]);
    }
  }
  c.x = 0;
}

// 文字挿入
void insertChar(char ch){
  int i;
  int length = strLen(textBuffer[current]) + 1; // 挿入後の文字数

  if (length == ROWS){
    addNewLine();
    length = 1; // 挿入後の文字数
  }

  for(i = 0; i < BUFLEN + 2; i = i + 1){
    d[i] = '\0';
  }

  // 更新する情報を作成
  for(i = 0; i < length; i = i + 1){
    // 挿入部分まではそのまま
    if(i < c.x){
      d[i] = textBuffer[current][i];
    } else {
      // 挿入部分後は１つずらす
      if(i > c.x){
        d[i] = textBuffer[current][i-1];
      } else if(i == c.x){
      // 挿入部分に代入
        d[i] = ch;
      }
    }
  }

  moveRight();
  // 内容更新
  strNcpy(textBuffer[current], d, length);
}

// 文字削除
void removeChar(){
  // その行の内容が０なら後ろの行から詰める
  if(strLen(textBuffer[current]) == 0){
    if(current == 0){
      return;
    }
    for (int i = current ; i < lines; i = i + 1){
      strCpy(textBuffer[i-1], textBuffer[i]);
    }
    lines = lines - 1;
    moveUp();
    c.x = strLen(textBuffer[current]) - 1;
  } else {
    // 後ろの文字を詰める
    // fixme \rをけすと\nがのこるためカーソルが一段さがる
    for(int i = c.x; i < strLen(textBuffer[current]); i = i + 1){
      textBuffer[current][i] = textBuffer[current][i+1];
    }
    // 最後の文字はnullにする
    textBuffer[current][strLen(textBuffer[current])] = '\0';
  }
}

void clear(){
  printf("\x1b[2J\x1b[H");
}

void moveCursor(){
  // カーソル移動
  printf("\x1b[%d;%dH", (c.y+1), (c.x+1));
}

// 画面表示
void display(){
  // 画面クリア
  printf("\x1b[2J\x1b[H");
  int end = lines + 1;
  if(end >  COLUMNS){
    end = COLUMNS;
  }
  // 表示
  for(int i = top; i < top + end; i = i + 1){
    printf("\r");
    printf("%s", textBuffer[i]);
    if (strRchr(textBuffer[i], '\n') == -1) {
      printf("\n");
    }
  }
  moveCursor();
}

// 入力文字の処理
void keyboard(char key){
    // todo エスケープシーケンスで動くようにする
    if (key == 'u'){  // up
      moveUp();
      printf("\x1b[1A");
      display();
      return;
    }else if (key == 'd'){  // down
      moveDown();
      display();
      return;
    } else if (key == 'r'){ // right
      moveRight();
      printf("\x1b[1C");
      return;
    } else if (key == 'l'){  // left
      moveLeft();
      printf("\x1b[1D");
      return;
    } else if (key == chr(9)){    // tab
      for(int i = 0; i < 8; i = i + 1){
        insertChar(' ');
      }
      return;
    } else if (key == '\x08'){    // del
      removeChar();
      moveLeft();
      display();
      return;
    } else if (key == '\r' || key == '\n'){
      printf("\r");
      insertChar('\n');
      addNewLine();
      display();
      return;
    }
    insertChar(key);
    printf("%c", key);
    return;
}

// ファイルの内容を処理
void loadFile(char[] fileName) {
  FILE fp;
  char ch;
  fp = fopen(fileName, "r"); // ファイルを開く
  if (fp == null) {
    perror(fileName);
    printf("\x1b[2J\x1b[H");
  } else {
    while(!feof(fp)) {
      ch = fgetc(fp);
      keyboard(ch);
    }
    fclose(fp);
  }
}

// ファイルに書き込む
void saveFile(char[] fileName) {
  #ifndef C
    remove(fileName);
  #endif

  FILE fp;
  fp = fopen(fileName, "w");
  if (fp == null) {
    perror(fileName);
    return;
  }
  for(int i = 0; i <= lines; i = i + 1){
    fprintf(fp, "%s", textBuffer[i]);
  }
  fclose(fp);
}

public int main(int argc, char[][] argv){
  if(argc!=2){
    fprintf(stderr, "Usage, %s <filename>\n", argv[0]);
    return 1;
  }
  init();
  char[] fileName = argv[1];

  char ch;
  int orgMode = ttyCtl(TTYCTL_GETMODE, 0);     // 普通のモード
  int rawMode = orgMode & ~TTYCTL_MODE_ECHO & ~TTYCTL_MODE_COOKED;  // １文字入力

  stdout.buf = null;  // stdoutのバッファリングを禁止
  clear();

  // ファイル読み込み
  loadFile(fileName);

  ttyCtl(TTYCTL_SETMODE, rawMode);
  while(true){
    // 文字入力
    ttyRead(kbdBuf, 1);

    // qを押したら終わり
    // todo 終わり方をかんがえる
    ch = kbdBuf[0];
    if(ch == 'q'){
      break;
    }
    keyboard(ch);
  }
  ttyCtl(TTYCTL_SETMODE, orgMode);

  // save
  saveFile(fileName);

  clear();
  printf("\r\n");
  return 0;
}
