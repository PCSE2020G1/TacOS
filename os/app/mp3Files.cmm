/*
 * TacOS Source Code
 *    Tokuyama kousen Advanced educational Computer.
 *
 * Copyright (C) 2020 by
 *                      Dept. of Computer Science and Electronic Engineering,
 *                      Tokuyama College of Technology, JAPAN
 *
 *   上記著作権者は，Free Software Foundation によって公開されている GNU 一般公
 * 衆利用許諾契約書バージョン２に記述されている条件を満たす場合に限り，本ソース
 * コード(本ソースコードを改変したものを含む．以下同様)を使用・複製・改変・再配
 * 布することを無償で許諾する．
 *
 *   本ソースコードは＊全くの無保証＊で提供されるものである。上記著作権者および
 * 関連機関・個人は本ソースコードに関して，その適用可能性も含めて，いかなる保証
 * も行わない．また，本ソースコードの利用により直接的または間接的に生じたいかな
 * る損害に関しても，その責任を負わない．
 *
 *
 */

/*
 * mp3Files.cmm : MP3ファイルの一覧
 *
 * 2020.09.16 : 新規作成
 * 2020.11.20 : TagInit()追加
 * 2020.11.25 : TaCOSに適したものに修正(ファイルの中身を読み出すところまで)
 * 2020.11.27 : フレーム数を数える処理の一部を追加
 * 2020.11.28 : ファイルサイズ削減, gcd()追加
 * 2020.11.29 : フレームカウント処理完成
 *              再生時間計算処理完成
 *              func_cal(), func_atoi, dtob(), subRound()追加
 * 2020.11.30 : csvファイル読み込み処理追加
 *              debugflag追加(フレームカウント処理は結構時間がかかるため他デバッグの時はスキップ)
 * 2020.12.01 : アーティスト情報などを取得する部分を追加(未完成)
 * 2020.12.02 : タグ情報取得部分完成
 *              func_itoa()追加
 *              printF文の削除
 *
 * $Id$
 *
 */

#include <fs.hmm>
#include <util.hmm>
#include <mm.hmm>
#include "appUtil.hmm"
#include "mp3Files.hmm"


#define MUSIC_NAME_SIZE 20 //曲名のサイズ
#define ART_NAME_SIZE 20 //アーティスト名のサイズ
#define ALBAM_NAME_SIZE 20 //アーティスト名のサイズ
#define func_cal(a, s) ((a % s)*10)


char[] str_line = array(32); //1行読み込む一時変数
char[] file_mp3 = array(MUSIC_NAME_SIZE+5); //拡張子を付けたファイル名を格納する一次変数
char[] tag_str = array(10);
char[] tag_tmp = array(5);
char[] buf = array(32);

boolean debugflag = false; //スキップ用のフラグ true:skip false:execute

int[] bin_p = {1, 2, 4, 8};
int[][] bit_rate_table_1 = {{1, 1, 1}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0},
                            {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0},
                            {0, 0, 0}, {288, 160, 128}, {320, 192, 160}, {0, 0, 0},
                            {0, 0, 0}, {0, 0, 0}, {448, 384, 320}, {0, 0, 0}};
int[][] bit_rate_table_2 = {{1, 1, 1}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0},
                            {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0},
                            {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0},
                            {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
int[][] sample_rate = {{441, 220, 110}, {480, 240, 120}, {320, 160, 80}, {0, 0, 0}}; //int型は16bit(signed)なので、下二桁を落とす

char[] bin_tmp_1 = array(10);
char[] b = array(5);

public index_type[] index_list = array(INDEX_SIZE); //構造体配列の静的メモリ確保

//構造体
struct mp3_tag {
    char version_id; //1:version1.0, 2:version2.0, 3:version2.5
    char layer_id; //3:layer3, 2:layer2, 1:layer1
    int bit_rate;
    int sampling_h;
    char padding;
    int frame_cnt;
};


//-----------------------------------------------------------------------------
// MP3ファイルの一覧（ただし，最大５個）
//-----------------------------------------------------------------------------
// ５つのファイル名 -> 後で上限をあげる
public char[][] files = array(5, MUSIC_NAME_SIZE+5); //(ファイル数, ファイルの文字数) 1234567890.123
public int numFile;                                        // ファイルの個数

char[] mp3Dir = "/MP3"; //ディレクトリがどう構成されるか不明

void TagsInit();

// /MP3 ディレクトリからファイルの一覧を作る（初期化）
public void mp3FilesInit() {
  int fd;                                           // ファイルディスクリプタ
  if ((fd=open(mp3Dir, READ_MODE))<0) {
    panic("panic1:can't open MP3 Dir");
  }
  Dir_i dir; //appUtil.hmmで宣言されている
  //Dir構造体のnameメンバーは，大きさ12の文字配列で初期化されている必要があります(cmm.pdf 4.1.17 readDir)
  int i = 0;
  while (i<5 && (dir=readDir_i(fd, "MP3"))!=null) {   // 最大5つファイル名を読む -> 後で変更
    strCpy(files[i], dir.name); //ファイル名をfilesにコピー
    i = i + 1;
  }
  numFile = i;

  TagsInit();
  printF("end\n");

  close(fd);
}

// n 番目ファイル名を返す（1<=n && n<=5）-> 後で変更
public char[] mp3FilesGetName(int n) {
  if (1<=n && n<=numFile) {
    return files[n-1];
  }
  return null;
}


void subCpy(char[] target, char[] ori, int index, int n){
    for(int i=0;i<n;i=i+1){
        target[i] = ori[i+index];
    }
    target[n] = '\0';
    return;
}


//appUtil.cmmにあるstrCatを使うとうまく動かなかったので自作
public char[] subCat(char[] cat_s, char[] src){
  char[] s = malloc(sizeof(char)*32);
  int c_num = strLen(cat_s);
  int s_num = strLen(src);
  strCpy(s, cat_s);
  int index;
  for(index=0; index<s_num;index=index+1){
    s[c_num+index] = src[index];
  }
  s[c_num+index] = '\0';
  free(s);
  return s;
}


//引数aとbのgcdを計算する
int gcd(int a, int b){
    int c = 0;
    if((a<=0)||(b<=0)){
        //引数のエラー
        return -1;
    }
    if(a<b){
        //aのほうが小さい場合、aとbを入れ替える
        int tmp = a;
        a = b;
        b = tmp;
    }
    while((c=a%b)!=0){
        a = b;
        b = c;
    }
    return b;
}


//decimal -> binary
void dtob(char[] binary, int decimal){
    int i;
    for(i=7;decimal>0; i=i-1){
        binary[i] = chr((decimal%2)+ord('0'));
        decimal = decimal/2;
    }
    if(i!=0){
        for(int t=0;t<=i;t=t+1){
            binary[t] = '0';
        }
    }
    binary[8] = '\0';
}


//四捨五入計算用の関数
int subRound(int a, int d){
    if(((a%d)/(d/10))>=5){
        return a/d + 1;
    } 
    return a/d;
}


//_AtoI()が謎だったので似たような関数を作成 ascii -> int
public int func_atoi(char[] str, int len){
  int tmp, sum = 0;
  for(int i=0; len>0; i=i+1){
    tmp = ord(str[i]) - ord('0');
    for(int p=1; p<len; p=p+1){
      tmp = tmp*10;
    }
    sum = sum + tmp;
    len = len - 1;
  }
  return sum;
}


//_ItoAもよくわからなかったため似た関数を作成 int -> ascii
public char[] func_itoa(int a){
  char[] str = malloc(sizeof(char)*5);
  if(48 <= (a+ord('0')) && (a+ord('0')) <= 57){ //0~9ならば
      str[0] = chr(a+ord('0'));
      str[1] = '\0';
      return str;
  } else{ //10以上
      int cnt = 0, q = a, i;
      while(q > 10){ //桁数
          q = q / 10;
          cnt = cnt + 1;
      }
      str[0] = chr(q+ord('0'));
      q = a;
      for(i=1; i<cnt; i=i+1){
          for(int t=0; t<(cnt-i); t=t+1){
              q = q / 10;
          }
          q = q%10;
          str[i] = chr(q+ord('0'));
          q = a;
      }
      int ama = a%10;
      str[i] = chr(ama+ord('0'));
      str[i+1] = '\0';
      return str;
  }
  free(str);
  return "0";
}


void TagsInit(){
  int fp;
  int frame_size;
  int step = 0;
  mp3_tag tag;
  boolean id_flag = false, not_flag = false;


  //構造体リストの動的確保
  for(int i=0; i<INDEX_SIZE; i=i+1){
      index_list[i] = malloc(sizeof(index_type));
  }
  //構造体の中身の配列動的確保
  for(int i=0; i<INDEX_SIZE; i=i+1){
      index_list[i].music_name = malloc(sizeof(char)*MUSIC_NAME_SIZE);
      index_list[i].art_name = malloc(sizeof(char)*ART_NAME_SIZE);
      index_list[i].albam_name = malloc(sizeof(char)*ALBAM_NAME_SIZE);
  }
  if((fp=open("index.csv", READ_MODE))>=0){ //インデックスファイルが存在したら
    str_line = malloc(sizeof(char)*32);
    //最初の行は空読み
    read(fp, buf, 31);

    //各行を処理する
    for(int i=0; i<5; i=i+1){
      int t;
      read(fp, buf, 1);
      for(t=0; ord(buf[0])!=10; t=t+1){
        if(buf[0] == ','){
          str_line[t] = '\0';
          if(step == 0){ //music_name
            strCpy(index_list[i].music_name, str_line);
          } else if(step == 1){ //id
            index_list[i].id = func_atoi(str_line, t);
          } else if(step == 2){ //play_cnt
            index_list[i].play_cnt = func_atoi(str_line, t);
          } else if(step == 3){ //art_name
            strCpy(index_list[i].art_name, str_line);
          } 
          t = -1;
          step = step + 1;
        } else{
          str_line[t] = buf[0];
        }
        read(fp, buf, 1);
      }
      str_line[t] = '\0';
      if(step == 4){ //song_len
        index_list[i].song_len = func_atoi(str_line, t);
      }
      step = 0;
      printF("%s / %d / %d / %s / %d\n", index_list[i].music_name, index_list[i].id, index_list[i].play_cnt, index_list[i].art_name, index_list[i].song_len);
    }
    free(str_line);
  } else{ //インデックスファイルが存在しない(初期起動)
    tag = malloc(sizeof(mp3_tag));
    tag_str = malloc(sizeof(char)*10);
    tag_tmp = malloc(sizeof(char)*5);
    bin_tmp_1 = malloc(sizeof(char)*10);
    b = malloc(sizeof(char)*5);
    for(int p=0;p<numFile;p=p+1){
      char[] d = "./MP3/"; //パス指定
      file_mp3 = subCat(d, files[p]); //strCatと同じ動き
      //タグ格納(初期値)
      strCpy(index_list[p].music_name, files[p]); //拡張子付き
      index_list[p].id = p;
      strCpy(index_list[p].art_name, "NO_NAME"); //アーティスト名が決められていたら更新
      strCpy(index_list[p].albam_name, "NONE"); //アルバム名が決められていたら更新
      index_list[p].play_cnt = 0;
      //
      tag.sampling_h = 0;
      int quo_1 = 1, quo_2 = 1;
      int w = 0;
      id_flag = false;
      not_flag = false;

      
      if ((fp=open(file_mp3, READ_MODE))<0) {
        panic("panic2:can't open MP3 files");
      }
      while(debugflag == false){
        read(fp, buf, 1);
        //5文字か6文字以上だとタグとくっついてしまう -> 何とかタグ部分と分ける必要がある
        if(isPrint(buf[0]) == true && ord(buf[0]) != 0 && not_flag == false){
          while(true){
            if(isDigit(buf[0]) == true || isUpper(buf[0]) == true || isLower(buf[0]) == true){
              tag_str[w] = buf[0];
              w = w + 1;
            }
            read(fp, buf, 1);
            if(isPrint(buf[0]) == false || ord(buf[0]) == 0){
              break;
            }
          }
          tag_str[w] = '\0';
          if(w >= 5){ //文字数が長いとタグがくっついている可能性がある
            for(int i=0; i<4; i=i+1){
              tag_tmp[i] = tag_str[w-(4-i)];
            }
            if(strCmp(tag_tmp, "TPE1") == 0 || strCmp(tag_tmp, "TALB") == 0){
              tag_str[w-4] = '\0';
            }
            tag_tmp[4] = '\0';
          }
          if(step == 1){
            strCpy(index_list[p].art_name, tag_str);
            step = 0;
          } else if(step == 2){
            strCpy(index_list[p].albam_name, tag_str);
            step = 0;
          }
          if(strCmp(tag_str, "TPE1") == 0 || strCmp(tag_tmp, "TPE1") == 0){
            tag_tmp[0] = '\0';
            step = 1;
          } else if(strCmp(tag_str, "TALB") == 0 || strCmp(tag_tmp, "TALB") == 0){
            tag_tmp[0] = '\0';
            step = 2;
          } if(tag_str[0]=='I' && tag_str[1]=='D' && tag_str[2]=='3'){
            id_flag = true;
          } 
          if(id_flag == false){
            not_flag = true;
            tag_str[0] = '\0';
          }
          w = 0;
        }
        if(ord(buf[0])==255){
          read(fp, buf, 1);
          //decimal -> binary
          dtob(bin_tmp_1, ord(buf[0]));
          //
          //B:version
          subCpy(b, bin_tmp_1, 3, 2);
          if(strCmp(b, "00") == 0){
              tag.version_id = '3';
          } else if(strCmp(b, "01") == 0){
              ;
          } else if(strCmp(b, "10") == 0){
              tag.version_id = '2';
          } else if(strCmp(b, "11") == 0){
              tag.version_id = '1';
          } else{
              tag.version_id = '0';
          }
          //
          //C:layer
          subCpy(b, bin_tmp_1, 5, 2);
          if(strCmp(b, "00") == 0){
              tag.layer_id = '0'; //not used
          } else if(strCmp(b, "01") == 0){
              tag.layer_id = '3';
          } else if(strCmp(b, "10") == 0){
              tag.layer_id = '2';
          } else if(strCmp(b, "11") == 0){
              tag.layer_id = '1';
          }
          //
          //next header(third)
          read(fp, buf, 1);
          //decimal -> binary
          dtob(bin_tmp_1, ord(buf[0]));
          //
          //E:bit rate
          subCpy(b, bin_tmp_1, 0, 4);
          int bin_num = 0;
          //binary -> decimal
          for(int i=0;i<=3;i=i+1){
              if(b[3-i]=='1'){
                  bin_num = bin_num + bin_p[i];
              }
          }
          if(tag.version_id == '1'){
              tag.bit_rate = bit_rate_table_1[bin_num][ord(tag.layer_id)-ord('0')-1];
          } else if(tag.version_id == '2' || tag.version_id == '3'){
              tag.bit_rate = bit_rate_table_2[bin_num][ord(tag.layer_id)-ord('0')-1];
          }
          //
          //F:sampling rate
          subCpy(b, bin_tmp_1, 4, 2);
          int sampling_num = 0;
          for(int i=0;i<=1;i=i+1){
              if(b[1-i]=='1'){
                  sampling_num = sampling_num + bin_p[i];
              }
          }
          if(tag.version_id != '0'){
              tag.sampling_h = sample_rate[sampling_num][ord(tag.version_id)-ord('0')-1];
          }
          //
          //G:padding
          char b1 = bin_tmp_1[6];
          printF("%c\n",b1);
          if(b1 == '0'){
              tag.padding = '0';
          } else{
              tag.padding = '1';
          }
          if(gcd(tag.bit_rate*10, tag.sampling_h) > 0){
            quo_1 = gcd(tag.bit_rate*10, tag.sampling_h);//最大公約数
          }
          if(tag.layer_id == '1'){
            if(gcd(12, tag.sampling_h/quo_1) > 0){
              quo_2 = gcd(12, tag.sampling_h/quo_1);
            }
            frame_size = (((12 / quo_2)*(tag.bit_rate*10 / quo_1) / ((tag.sampling_h / quo_1) / quo_2)) + (ord(tag.padding) - ord('0')))*4;
          } else if(tag.layer_id == '2' || tag.layer_id == '3'){
              if(tag.version_id == '1'){
                if(gcd(144, tag.sampling_h/quo_1) > 0){
                  quo_2 = gcd(144, tag.sampling_h/quo_1);
                }
                frame_size = (((144 / quo_2)*(tag.bit_rate*10 / quo_1)) / ((tag.sampling_h / quo_1) / quo_2)) + (ord(tag.padding) - ord('0'));
              }
          } else if(tag.layer_id == '3' && tag.version_id == '3'){
            if(gcd(72, tag.sampling_h/quo_1) > 0){
              quo_2 = gcd(72, tag.sampling_h/quo_1);
            }
            frame_size = (((72 / quo_2)*(tag.bit_rate*10 / quo_1)) / ((tag.sampling_h / quo_1) / quo_2)) + (ord(tag.padding) - ord('0'));
          }
          //
          //next frame
          for(int i=0;i<=frame_size-3;i=i+1){
              read(fp, buf, 1);
          }
          while(true){
            tag.frame_cnt = tag.frame_cnt + 1;
            read(fp, buf, 1);
            if(ord(buf[0])!=251){ //end of file fb以外が来たら終了
              printF("finish\n");
              break;
            }
            int one_loop = (frame_size-1)%32;
            for(int i=0;i<((frame_size-1)/32);i=i+1){
              read(fp, buf, 32);
              if(i==0){
                dtob(bin_tmp_1, ord(buf[0]));
                if(bin_tmp_1[6]=='1'){
                  one_loop = one_loop + 1;
                }
              }
            }
            for(int i=0;i<one_loop;i=i+1){
              read(fp, buf, 1);
            }
          }
          int sum = tag.frame_cnt * (1152 / tag.sampling_h);
          sum = sum + subRound(tag.frame_cnt, 10) * (func_cal(1152, tag.sampling_h) / tag.sampling_h);
          sum = sum + subRound(tag.frame_cnt, 100) * (func_cal(func_cal(1152, tag.sampling_h), tag.sampling_h) / tag.sampling_h);
          sum = sum + subRound(tag.frame_cnt, 1000) * (func_cal(func_cal(func_cal(1152, tag.sampling_h), tag.sampling_h), tag.sampling_h) / tag.sampling_h);
          index_list[p].song_len = sum / 100;
          tag.frame_cnt = 0;

          break;
        }
      }
      close(fp);
    }
    free(b);
    free(bin_tmp_1);
    free(tag);
  }
}
